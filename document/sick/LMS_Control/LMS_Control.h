//*****************************************************************************/
//
// LMS_Control.h
//
// By: Joseph Parish 
// Special thanks to David Yuen whose code formed the starting point for 
// this software.
//
// This software forms a minimal basis for interfacing with a SICK LMS 290
// You may need some or all of the following #includes in your stdafx.h
//
// #include <Windows.h>
// #include <stdio.h>
// #include <sys/types.h>
// #include <sys/timeb.h>
// #include <iostream>
// #include <fstream>
// #include <tchar.h>
// #include <time.h>
// #include <stdlib.h>
// #include <vcclr.h>
// #include <string>
// #include <math.h>
// #include <conio.h>
//
//
//*****************************************************************************/

#pragma once

#include "stdafx.h"

#define STX 0x02   /*every PC->LMS packet is started by STX*/ 
#define ACKSTX 0x06 /*every LMS->PC packet is started by ACKSTX*/
#define LEN100X1 101
#define LEN100X5 201
#define LEN100X25 401
#define LEN180X1 181
#define LEN180X5 361
#define RANGE100 100
#define RANGE180 180
#define RES1 1
#define RES5 0.5
#define RES25 0.25
#define MAXPACKET 812

#define ANGLE_RES_100X1 0
#define ANGLE_RES_100X0_5 1
#define ANGLE_RES_100X0_25 2
#define ANGLE_RES_180X1 3
#define ANGLE_RES_180X0_5 4
#define BR_500000 3
#define BR_38400 2
#define BR_19200 1
#define BR_9600 0
#define MAXDATA 802
#define POLAR 0
#define RECT 1

typedef unsigned char uchar;

/*the cmd and ack packets for the 5 different range/resolution modes*/
const uchar ANGLE_RES[5][11]={
							{0x02,0x00,0x05,0x00,0x3B,0x64,0x00,0x64,0x00,0x1D,0x0F}, //100x1
							{0x02,0x00,0x05,0x00,0x3B,0x64,0x00,0x32,0x00,0xB1,0x59}, //100x0.5 
							{0x02,0x00,0x05,0x00,0x3B,0x64,0x00,0x19,0x00,0xE7,0x72}, //100x0.25
							{0x02,0x00,0x05,0x00,0x3B,0xB4,0x00,0x64,0x00,0x97,0x49}, //180x1
							{0x02,0x00,0x05,0x00,0x3B,0xB4,0x00,0x32,0x00,0x3B,0x1F}  //180x0.5
							};
const uchar ACK_ANGLE_RES[5][14]={
						{0x06,0x02,0x80,0x07,0x00,0xbb,0x01,0x64,0x00,0x64,0x00,0x10,0x4F,0xBD},//100x1
						{0x06,0x02,0x80,0x07,0x00,0xbb,0x01,0x64,0x00,0x32,0x00,0x10,0x17,0x10},//100x0.5 
						{0x06,0x02,0x80,0x07,0x00,0xbb,0x01,0x64,0x00,0x19,0x00,0x10,0xBB,0x46},//100x0.25
						{0x06,0x02,0x80,0x07,0x00,0xbb,0x01,0xb4,0x00,0x64,0x00,0x10,0x5B,0x30},//180x1
						{0x06,0x02,0x80,0x07,0x00,0xbb,0x01,0xb4,0x00,0x32,0x00,0x10,0x03,0x9D} //180x0.5
						};

/*the cmd and ack packets different measurement unit modes*/
const uchar SETTINGS_MODE[16]={0x02,0x00,0x0A,0x00,0x20,0x00,0x53,0x49,0x43,0x4B,0x5F,0x4C,0x4D,0x53,0xBE,0xC5};
const uchar ACK_SETTINGS_MODE[]={0x06,0x02,0x80,0x03,0x00,0xA0,0x00,0x10,0x16,0x0A};
const uchar MEASURE_MODE[2][39]={
	{0x02,0x00,0x21,0x00,0x77,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x02,0x02,0x00,0x00,0x00,//millimeters
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x7E},
	{0x02,0x00,0x21,0x00,0x77,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x02,0x00,0x00,0x00,//centimeters
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE8,0x72}
	};
const uchar ACK_MEASURE_MODE[2][44]={
	{0x06,0x02,0x80,0x25,0x00,0xf7,0x00,0x00,0x00,0x46,0x00,0x00,0x00,0x01,0x00,0x00,0x02,0x02,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x7E,0x10,0x24,0x0B},//millimeters
	{0x06,0x02,0x80,0x25,0x00,0xf7,0x00,0x00,0x00,0x46,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x02,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x72,0x10,0x9C,0x67} //centimeters
	};

//cmd packet for getting LMS status
const uchar GET_STATUS[]= {0x02,0x00,0x01,0x00,0x31,0x15,0x12};

/*the cmd packets for setting transfer speed and  controlling the start and stop of measurement*/
const uchar START_CONTINUOUS[8]={0x02,0x00,0x02,0x00,0x20,0x24,0x34,0x08};//Start
const uchar STOP_CONTINUOUS[8]={0x02,0x00,0x02,0x00,0x20,0x25,0x35,0x08};//Stop

const uchar BAUD_RATE[4][8]={ 
						 {0x02,0x00,0x02,0x00,0x20,0x42,0x52,0x08},//9600
						 {0x02,0x00,0x02,0x00,0x20,0x41,0x51,0x08},//19200
						 {0x02,0x00,0x02,0x00,0x20,0x40,0x50,0x08},//38400
						 {0x02,0x00,0x02,0x00,0x20,0x48,0x58,0x08} //500000
						};

/*the ack packet for the above commands*/
const uchar CMD_ACK[]={0x06,0x02,0x80,0x03,0x00,0xa0,0x00,0x10,0x16,0x0A};

// cmd packet for requesting LMS Type. 
const uchar REQ_TYPE[]={0x02,0x00,0x01,0x00,0x3A,0x1E,0x12};

const DWORD CBR_500000 = 500000;
const DWORD CBR[]={CBR_9600, CBR_19200, CBR_38400, CBR_500000};


class LMSControl  
{

private:
	//data
	HANDLE	m_hCommPort;	//File Handle
	DCB dcbSerialParams;
	bool isContinuousOutput;
	int dataLength;
	double range;
	double res;
	
	//funtions
	bool ReadLMSmsg(int, uchar*);
	bool ReadLMS(int, uchar*);
	bool GetByte(uchar&);
	void SendMessage(int, const uchar*);
	void SendByte(const uchar*);
	void ToIntArrayPolar(int, uchar*, int*);
	unsigned short LMSCRC(unsigned char* theBytes, int lenBytes);
	void Reconfigure();

public:
	//functions
	LMSControl();
	~LMSControl();
	HANDLE ConfigureComPort(LPCSTR comPort);
	void ChangeAngleRes(int); 
	void ChangeBaudRate(int);
	void StartContinuousOutput();
	void StopContinuousOutput();	
	int ReadLMSData(int*, int);
	int PolarToRect(int, int*, int*);
	//*****************************************************
	// Returns the number of points the laser reads
	// if you use rectangular coordinates, the actual
	// length of data returned to you is twice dataLength
	//*****************************************************
	int GetDataLength(); 
	
};
